\input{data/preamble}

\begin{document}
\section{Motivation}
% \SidebarCite{book:javase15-std}
\begin{frame}{Motivation}
% FELIX&FLO
\end{frame}
% \SidebarReset
\section{Background}
\makeatletter % faulheit!
\begin{frame}[c]{Pipes}
\centering
% \begin{layout-imageonly}
\begin{tikzpicture}[,codeouthl,every path/.append style={line cap=round,rounded corners=2pt}]
   \onslide<2->{\node[circle,minimum size=1cm,fill] (@) at(0,0) {};}
   \onslide<3->{\draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@i);}
   \onslide<4->{\draw[-{Kite[scale=.8]},very thick](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0) coordinate (@O);}
   \onslide<5->{\draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};}
   \onslide<6->{\node[below,darkgray] (wc) at(@.south) {\sbfamily\bbash{wc -l}};}
   \only<7->{
   \scope[xshift=-6cm]
   \onslide<7->{\node[circle,minimum size=1cm,fill] (@) at(0,0) {};
   \draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@I);
   \draw[-{Kite[scale=.8]},very thick](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0)  coordinate (@o);
   \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};}
   \onslide<8->{\node[below,darkgray] (cat) at(@.south) {\sbfamily\bbash{cat makefile}};}
   \endscope
   }
   \only<9->{
      \pgfinterruptboundingbox
      \draw[-Kite,very thick,codeouthl!70!white] (@o) -- (@i) coordinate[pos=.5] (@@);
      \path (@@|-wc) node[darkgray,xshift=-1mm] {\sbfamily\T{|}};
      \endpgfinterruptboundingbox
   }
   \only<10->{
      \draw[decorate,decoration={brace,mirror,amplitude=2pt},thick,black,sharp corners] ([yshift=-1.25cm]@I) to[edge node={node[below=2pt] {Producer}}] ([yshift=-1.25cm]@o);
      \draw[decorate,decoration={brace,mirror,amplitude=2pt},thick,black,sharp corners] ([yshift=-1.25cm]@i) to[edge node={node[below=2pt] {Consumer}}] ([yshift=-1.25cm]@O);
   }
   % TODO: next slide, connect them with the pipe symbol
   % TODO: make programs black to read them better
\end{tikzpicture}
% \end{layout-imageonly}
% each program run in the command line has three data streams connected to it:
% \begin{tikzpicture}[overlay,remember picture]
% \scope[shift={(current page.south west)},shift={(\beamer@leftmargin,1cm)}]
% \endscope
% \end{tikzpicture}
\end{frame}

% TODO: example from: https://www.usenix.org/system/files/login/articles/105438-Tange.pdf
\begin{frame}[c]{Pipes\rhead{II}}
\centering\vspace*{.125em}
\begin{layout-imageonly}
\begin{tikzpicture}[,codeouthl,every path/.append style={line cap=round,rounded corners=2pt}]
   \only<-4|handout:0>{\node[circle,minimum size=1cm,fill] (@) at(0,0) {};
   \pgfinterruptboundingbox
   \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};
   \endpgfinterruptboundingbox
   }
   \only<5->{
      \pgfinterruptboundingbox
      \node[rectangle,minimum width=3cm,minimum height=2cm,very thick,draw] (@) at(0,0) {};
      \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};
      \endpgfinterruptboundingbox
   }
   \onslide<6->{
      \node[circle,minimum size=1cm,fill] (@sub) at(0,0) {};
      \draw[{Kite[scale=.8]}-,very thick,line cap=rect](@sub.west) -- ++(-1cm+.1mm,0) coordinate (@i);
      \draw[-{Kite[scale=.8]},very thick](@sub.east) -- ++(1,0) coordinate (@O);
      \draw[-{Kite[scale=.8]},very thick](@sub.north) -- ++(0,.5);
      \node[below,darkgray,scale=.8] (wc) at(@sub.south) {\sbfamily\bbash{gzip}};
   }
   % no O1 for xargs: https://www.mankier.com/7/parallel_alternatives#DIFFERENCES_BETWEEN_GNU_Parallel_AND_ALTERNATIVES-DIFFERENCES_BETWEEN_xargs_AND_GNU_Parallel
   \draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@i);
   \draw[-{Kite[scale=.8]},very thick,line cap=rect](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0) coordinate (@O);
   \onslide<4->{\node[below,darkgray] (wc) at(@.south) {\sbfamily\bbash{xargs gzip}};}
   % NOTE: use --keep! and maybe --recursive for data

   \scope[xshift=-7cm]
   \node[circle,minimum size=1cm,fill] (@) at(0,0) {};
   \draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@I);
   \draw[-{Kite[scale=.8]},very thick](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0)  coordinate (@o);
   \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};
   \onslide<2->{\node[below,darkgray] (ls) at(@.south|-wc.north) {\sbfamily\bbash{find . -type f}};}
   \onslide<3->{\node[below=2mm,inner sep=1.5mm,fill=gray!10!white,rounded corners=2pt,text width=3cm,text=black,align=left,font=\ttfamily,scale=.85] at([xshift=1cm]ls.south) {%
      ./Dockerfile\\
      ./run-docker\\
      ./makefile\\
      \ldots
   };}
   % ls hat Probleme, ist hier nur als einfaches Beispiel:
   % https://unix.stackexchange.com/questions/128985/why-not-parse-ls-and-what-to-do-instead
   \endscope
   \draw[-Kite,very thick,codeouthl!70!white] (@o) -- (@i) coordinate[pos=.5] (@@);
   \path (@@|-wc) node[darkgray,xshift=-1mm] {\sbfamily\T{|}};
   % TODO: benchmarks
\end{tikzpicture}
\end{layout-imageonly}
% each program run in the command line has three data streams connected to it:
\end{frame}

\begin{frame}[c]{Pipes\rhead{III}}
   \centering\vspace*{.125em}
\begin{layout-imageonly}
   \begin{tikzpicture}[,codeouthl,every path/.append style={line cap=round,rounded corners=2pt}]
      \onslide<-2>{\pgfinterruptboundingbox
      \node[rectangle,minimum width=3cm,minimum height=2cm,very thick,draw] (@) at(0,0) {};
      \endpgfinterruptboundingbox}
      % keeps old @ to avoid jumps
      \onslide<2->{\node[below,darkgray] (wc) at(@.south) {\only<-2|handout:0>{\sbfamily\bbash{parallel gzip}}\only<3->{\phantom{\sbfamily\bbash{parallel gzip}}}};}
      \only<-2|handout:0>{
         \node[circle,minimum size=1cm,fill] (@sub) at(0,0) {};
         \draw[{Kite[scale=.8]}-,very thick,line cap=rect](@sub.west) -- ++(-1cm+.1mm,0) coordinate (@i);
         \draw[-{Kite[scale=.8]},very thick](@sub.east) -- ++(1,0) coordinate (@O);
         \draw[-{Kite[scale=.8]},very thick](@sub.north) -- ++(0,.5);
         \node[below,darkgray,scale=.8] (gz-wc) at(@sub.south) {\sbfamily\bbash{gzip}};
      % TODO: multiples
      }
      \only<3->{
         \pgfinterruptboundingbox
         \node[rectangle,minimum width=3cm,minimum height=5.5cm,very thick,draw] (@) at(0,0) {};
         \endpgfinterruptboundingbox
         \fill (@.west)++(0,.25) arc(90:-90:.25);
         \fill (@.east)++(0,.25) arc(90:270:.25);
         \fill (@.north)++(.25,0) arc(0:-180:.25);

         % hardcode copy-paste love
         \node[circle,minimum size=1cm,fill] (@sub2) at(0,-1.75) {};
         \draw[{Kite[scale=.8]}-,very thick,line cap=rect](@sub2.west) -- ++(-1cm+.1mm+5mm,0) -- ++(-5mm,1.75);
         \draw[-{Kite[scale=.8]},very thick,shorten >=.25cm](@sub2.east) -- ++(1-.5,0) -- ++(.5,1.75);
         \draw[-{Kite[scale=.8]},very thick,codeouthl!60!white](@sub2.north) to[bend left=8] ++(0,.5+2*1.75-.25);
         \node[below,darkgray,scale=.8] (gz-wc) at(@sub2.south) {\sbfamily\bbash{gzip}};
         \node[circle,minimum size=1cm,fill] (@sub) at(0,0) {};
         \draw[{Kite[scale=.8]}-,very thick,line cap=rect](@sub.west) -- ++(-1cm+.1mm,0) coordinate (@i);
         \draw[-{Kite[scale=.8]},very thick](@sub.east) -- ++(1-.25,0) coordinate (@O);
         \draw[-{Kite[scale=.8]},very thick,codeouthl!60!white](@sub.north) to[bend right=8] ++(0,.5+1.75-.25);
         \node[below,darkgray,scale=.8] (gz-wc) at(@sub.south) {\sbfamily\bbash{gzip}};
         \node[circle,minimum size=1cm,fill] (@sub1) at(0,1.75) {};
         \draw[{Kite[scale=.8]}-,very thick,line cap=rect](@sub1.west) -- ++(-1cm+.1mm+5mm,0) -- ++(-5mm,-1.75);
         \draw[-{Kite[scale=.8]},very thick,shorten >=.25cm](@sub1.east) -- ++(1-.5,0)  -- ++(.5,-1.75);
         \draw[-{Kite[scale=.8]},very thick](@sub1.north) -- ++(0,.5);
         \node[below,darkgray,scale=.8] (gz-wc) at(@sub1.south) {\sbfamily\bbash{gzip}};
      }
      \draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@i);
      \draw[-{Kite[scale=.8]},very thick,line cap=rect](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0) coordinate (@O);
      \pgfinterruptboundingbox
      \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};
      \endpgfinterruptboundingbox

      \onslide<3->{\node[below,darkgray] (pgz) at(@.south) {\sbfamily\bbash{parallel gzip}};}
      % NOTE: use --keep! and maybe --recursive for data

      \scope[xshift=-7cm]
      \node[circle,minimum size=1cm,fill] (@) at(0,0) {};
      \draw[{Kite[scale=.8]}-,very thick](@.west) to[edge node={node[above,black] {\textsc{stdin}}}] ++(-2,0) coordinate (@I);
      \draw[-{Kite[scale=.8]},very thick](@.east) to[edge node={node[above,black] {\textsc{stdout}}}] ++(2,0)  coordinate (@o);
      \draw[-{Kite[scale=.8]},very thick](@.north) |- ++(2,.5) node[pos=.75,above,black] {\textsc{stderr}};
      \node[below,darkgray] (ls) at(@.south|-wc.north) {\sbfamily\bbash{find . -type f}};
      \node[below=2mm,inner sep=1.5mm,fill=gray!10!white,rounded corners=2pt,text width=3cm,text=black,align=left,font=\ttfamily,scale=.85] at([xshift=1cm]ls.south) {%
         ./Dockerfile\\
         ./run-docker\\
         ./makefile\\
         \ldots
      };
      \endscope
      \draw[-Kite,very thick,codeouthl!70!white] (@o) -- (@i) coordinate[pos=.5] (@@);
      \path (@@|-wc) node[darkgray,xshift=-1mm] {\sbfamily\T{|}};

      % TODO: benchmarks
   \end{tikzpicture}
\end{layout-imageonly}
% TODO: Ã¼bergang pipe animation
% Nicer: https://www.usenix.org/system/files/login/articles/105438-Tange.pdf
\end{frame}
% TODO: nice example clock:
% parallel -k echo {1}'{=3 $_=$_%2?":":" "=}'{2}{3} \
% ::: {0..12} ::: {0..5} ::: {0..9}
% from manual
% TODO: even with grouping, e.g by piping with 'sort' - a stateful operation which operates as "Flaschenhals"
% TODO: auch auf ::: und so eingehen % FLORIAN


\section{GNU \LogoParallel}
\begin{frame}[fragile]{A simple Bank}
\begin{layout-imageonly}
\begin{minted}{java}
/*\CodeFileMarker{Producer.java}*/
final var rand = new Random();

for (int i = 0; i < /*\Snode{n@}*/n/*\Snode{n@}*/; i++) {
   int from = rand.nextInt(/*\Snode{names}*/NAMES/*\Snode{names@}*/.length);
   int to = rand.nextInt(NAMES.length);
   System.out.format("%d %d %d%n", from, to, /*\Snode{value}*/rand.nextInt(100) * 10/*\Snode{value@}*/);
}
\end{minted}
\end{layout-imageonly}
\begin{minted}{java}
   Scanner scan = new Scanner(System.in);

   while (scan.hasNextLine()) {
       String input = scan.nextLine();

       String[] s = input.split(" ");

       System.out.println(Constants.names[Integer.parseInt(s[FROM])] + " " + -Integer.parseInt(s[VALUE]));
       System.out.println(Constants.names[Integer.parseInt(s[TO])] + " " + Integer.parseInt(s[VALUE]));

   }
   scan.close();
\end{minted}
\begin{minted}{java}
   Scanner scan = new Scanner(System.in);
   HashMap<String, Integer> acc = new HashMap<>();

   while (scan.hasNextLine()) {
       String input = scan.nextLine();
       String[] transaction = input.split(" ");

       if (transaction.length != 2) {
           System.out.println(input);
           continue;
       }

       if (!acc.containsKey(transaction[0])) {
           acc.put(transaction[0], 0);
       }

       acc.put(transaction[0], acc.get(transaction[0]) + Integer.parseInt(transaction[1]));

   }
   scan.close();

   acc.entrySet().forEach(entry -> {
       System.out.println(entry.getKey() + ": " + entry.getValue());
   });
\end{minted}
\begin{minted}{bash}
   java -jar producer.jar 100000 | parallel --pipe java -jar consumer.jar | yarn --silent start
   #java -jar producer.jar 100000 | parallel --pipe java -jar consumer.jar | java -jar accountant.jar
\end{minted}
\end{frame}

% \subsection{The Running-Example}
\begin{frame}{Fun!}
   grafik und Code
% wann sinnvoll usw.
% bank beispiel mit java  %  FELIX
\end{frame}

\subsection{History}
\begin{frame}{History}
   \begin{itemize}[<+(1)->]
      \itemsep10pt
      \item Originally two tools: xxargs and \LogoParallel. \begin{itemize}
         \itemsep5pt
         \item Parallel was originally a wrapper that generated a makefile and used \bbash{make -j} to do the parallelization
         \item xxargs and \LogoParallel got merged into parallel
         \item New objectives\flo{(s)?}: replace xargs and run commands in \LogoParallel. \flo{klarer machen, dass xargs?}
      \end{itemize}
      \item In 2010, \LogoParallel was adopted as an official \textsc{gnu} tool, named \textsc{gnu} \LogoParallel.
   \end{itemize}
   % Single-file to work easily, perl because seems to be widespread, problem: overhead (--tag option+, https://www.gnu.org/software/parallel/parallel_design.pdf)
\end{frame}


\subsection{Distribution}
\begin{frame}[fragile]{Distributed}
   GNU parallel can run jobs on remote servers. It uses ssh to communicate with the remote machines.\\
   \begin{minted}{bash}
      parallel -S $SERVER echo running on ::: $SERVER
   \end{minted}
   Transfer Files using rsync:
   \begin{minted}{bash}
      parallel -S $SERVER1 --transferfile {} --return {}.out --cleanup cat {} ">"{}.out ::: input_file
      // Shorthand
      parallel -S $SERVER1 --trc {}.out cat {} ">"{}.out ::: input_file
   \end{minted}
   \begin{minted}{bash}
      --basefile
      --workdir
      --onall
      --nonall non argument onall
      --tag for output
   \end{minted}
   Prevent sshd Overloading:
   \begin{minted}{bash}
      parallel -S $SERVER1 --sshdelay 0.2 echo ::: 1 2 3
   \end{minted}
   Multiplex connections:
   \begin{minted}{bash}
      --controlmaster
   \end{minted}


   %grafik und Code
   % erweiterungen wei verteilt mehrere Systeme % FELIX (-ssh oder so)
\end{frame}
\subsection{Data Encoding}
\begin{frame}{Data Encoding}
      Code Json, vs. yaml, vs...
   % objekte % FLORIAN (gson und so)
\end{frame}
\subsection{Other Languages}
\begin{frame}[fragile]{Other Languages}
   %Grafik und Code
   \begin{minted}{javascript}
      import { createInterface } from "readline";

      const readline = createInterface({
         input: process.stdin,
      });

      let accMap = new Map<String, number>();

const handleLine = (input: String) => {
  const s = input.split(" ");
  if (s.length != 2) {
    console.log(input);
    return;
  }
  if (!accMap.has(s[0])) accMap.set(s[0], 0);
  accMap.set(s[0], accMap.get(s[0])! + +s[1]);
};

readline.on("line", handleLine);

readline.on("close", () => {
  console.log(accMap);
});
   \end{minted}
   \begin{minted}{bash}
      java -jar producer.jar 100000 | parallel --pipe java -jar consumer.jar | yarn --silent start
      #java -jar producer.jar 100000 | parallel --pipe java -jar consumer.jar | java -jar accountant.jar
   \end{minted}
   % verschiedene Sprache % FELIX
   % TODO: timeout option?
\end{frame}

\subsection{Recap} % maybe not as separate bot in the bottom?
\begin{frame}{Recap}
   \begin{itemize}[<+(1)->]
      \itemsep12pt
      \item Producer-Consumer
      \item stream-based communication \begin{itemize}
         \item cf. Javas functional streams
         \item serialization and deserialization % TODO: talk about advantages and disadvantages
         \item decoupled programs (e.g., no shared memory)
      \end{itemize}
      \item TODO: distribution @Felix (chapter F)
      \item lock-free etc because producer-consumer
      \item TODO: other stuff?
   \end{itemize}
\end{frame}

\section{Inner Workings}
% TOOD: siebar note for bash only https://devdocs.io/bash/pipelines | https://www.gnu.org/software/bash/manual/bash.pdf
\begin{frame}{About pipes}
\begin{itemize}
   \item Execute each program in own subshell
   \item TODO: not sequential: \url{https://stackoverflow.com/a/32946581} os we execute al steps in parallel for free (producer-consumer) \url{https://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html\#tag_02_09_02}
   \item TODO: talk about redirection and sockets?
   \item load balacning \url{https://stackoverflow.com/questions/14039403/gnu-parallel-load-balancing}
   \item how does bash sync it?
\end{itemize}
% Semaphor => kann als solche verwendet werden
% Semaphor, Rechner Sockets, % FLO
% parallel nutzt die host-shell aus (deisgn: which shell to use, p11)
\end{frame}
\begin{frame}
 TODO: SPREADING BLOCKS OF DATA
 in \url{https://www.gnu.org/software/parallel/parallel.pdf}
 %  synchinc
\end{frame}

\section{Outlook?}
\begin{frame}{Look Out!}
% FELIX&FLO
% praktische Anwendungen
% optionen die wir nicht vorstellen
% gibt es eine geplante Weiterentwicklung? <- ne
% Alternativen: https://www.gnu.org/software/parallel/parallel_alternatives.pdf
% xargs hat -P, makefiles etc.
% -pipe vs pipepart, disk buffering
% sql support --sql-master etc.
% table support
% shebang
\end{frame}

\end{document}